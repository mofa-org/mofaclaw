name: MoFA Duplicate Issue Detection

on:
  issues:
    types: [opened, reopened]

permissions:
  issues: write
  contents: read

jobs:
  detect-duplicates:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Get current issue details
        id: current_issue
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issue = context.payload.issue;
            core.setOutput('number', issue.number);
            core.setOutput('title', issue.title || '');
            core.setOutput('body', issue.body || '');
            core.setOutput('url', issue.html_url);

      - name: Search for similar open issues
        id: search_issues
        env:
          CURRENT_ISSUE_TITLE: ${{ steps.current_issue.outputs.title }}
          CURRENT_ISSUE_NUMBER: ${{ steps.current_issue.outputs.number }}
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Read values safely from environment to avoid breaking JS when
            // titles contain backticks or other special characters.
            const currentTitle = process.env.CURRENT_ISSUE_TITLE || '';
            const currentNumber = parseInt(process.env.CURRENT_ISSUE_NUMBER || '0', 10);
            
            // Extract key words from title for search
            const searchTerms = currentTitle
              .toLowerCase()
              .replace(/[^\w\s]/g, ' ')
              .split(/\s+/)
              .filter(word => word.length > 3)
              .slice(0, 5)
              .join(' ');
            
            // Search for open issues with similar terms
            const { data: searchResults } = await github.rest.search.issuesAndPullRequests({
              q: `repo:${context.repo.owner}/${context.repo.repo} is:issue is:open ${searchTerms}`,
              per_page: 20
            });
            
            // Filter out current issue and get issue details
            const candidateIssues = searchResults.items
              .filter(issue => issue.number !== currentNumber)
              .slice(0, 10); // Limit to top 10 candidates
            
            const issuesData = [];
            for (const issue of candidateIssues) {
              try {
                const { data: fullIssue } = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                });
                issuesData.push({
                  number: issue.number,
                  title: issue.title,
                  body: fullIssue.body || '',
                  url: issue.html_url,
                  created_at: issue.created_at
                });
              } catch (e) {
                core.warning(`Failed to get details for issue #${issue.number}: ${e.message}`);
              }
            }
            
            core.setOutput('candidates', JSON.stringify(issuesData));
            core.info(`Found ${issuesData.length} candidate issues to check`);

      - name: Analyze duplicates with Gemini
        id: analyze_duplicates
        if: steps.search_issues.outputs.candidates != '[]'
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          CURRENT_ISSUE_TITLE: ${{ steps.current_issue.outputs.title }}
          CURRENT_ISSUE_BODY: ${{ steps.current_issue.outputs.body }}
          CURRENT_ISSUE_NUMBER: ${{ steps.current_issue.outputs.number }}
          CANDIDATE_ISSUES: ${{ steps.search_issues.outputs.candidates }}
        run: |
          set -euo pipefail
          
          echo "Starting duplicate analysis..."
          echo "Current issue: #${CURRENT_ISSUE_NUMBER}"
          echo "Title: ${CURRENT_ISSUE_TITLE}"
          echo "Candidates found: $(echo "${CANDIDATE_ISSUES}" | jq 'length')"
          
          PROMPT=$(cat <<PROMPT_EOF
          You are a duplicate issue detection assistant. Analyze if the current issue is a duplicate of any candidate issues.

          Current Issue:
          Number: ${CURRENT_ISSUE_NUMBER}
          Title: ${CURRENT_ISSUE_TITLE}
          Body:
          ${CURRENT_ISSUE_BODY}

          Candidate Issues:
          ${CANDIDATE_ISSUES}

          INSTRUCTIONS:
          1. Compare the current issue with each candidate issue.
          2. Determine if they describe the same bug, feature request, or problem.
          3. Consider:
             - Are they reporting the same underlying issue?
             - Do they have the same root cause?
             - Would fixing one resolve the other?
          4. If you find a duplicate, identify the BEST canonical issue (usually the one with more details, earlier creation date, or more engagement).
          5. If comments on either issue explicitly state they are NOT duplicates, respect that and don't mark as duplicate.

          Return ONLY a JSON object with this structure:
          {
            "is_duplicate": true or false,
            "canonical_issue_number": number (if duplicate, the issue number to link to),
            "confidence": "high" or "medium" or "low",
            "reason": "brief explanation"
          }

          If is_duplicate is false, canonical_issue_number can be null.
          PROMPT_EOF
          )
          
          echo "Prompt created (length: ${#PROMPT})"
          
          echo "Calling Gemini API..."
          
          # Encode prompt as JSON string
          PROMPT_JSON=$(echo "$PROMPT" | jq -Rs .)
          echo "Prompt JSON encoded (length: ${#PROMPT_JSON})"
          
          # Make API call with error handling
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
            "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${GEMINI_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "{
              \"contents\": [{
                \"role\": \"user\",
                \"parts\": [{\"text\": ${PROMPT_JSON}}]
              }]
            }" || echo "CURL_FAILED")
          
          # Extract HTTP status code (last line)
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          RESPONSE_BODY=$(echo "$RESPONSE" | sed '$d')
          
          echo "HTTP Status: ${HTTP_CODE}"
          echo "API Response received (length: ${#RESPONSE_BODY})"
          
          # Check for curl failure
          if [ "$RESPONSE_BODY" = "CURL_FAILED" ] || [ -z "$RESPONSE_BODY" ]; then
            echo "❌ Error: Failed to call Gemini API"
            echo "result=" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Check for HTTP errors
          if [ "$HTTP_CODE" != "200" ]; then
            echo "❌ Error: Gemini API returned HTTP $HTTP_CODE"
            echo "Response: $RESPONSE_BODY"
            echo "result=" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Check for API errors in response
          if echo "$RESPONSE_BODY" | jq -e '.error' > /dev/null 2>&1; then
            echo "❌ Error: Gemini API returned an error"
            echo "$RESPONSE_BODY" | jq '.error'
            echo "result=" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Extract result
          RESULT=$(echo "$RESPONSE_BODY" | jq -r '.candidates[0].content.parts[0].text // empty' 2>/dev/null || echo "")
          echo "Extracted result (length: ${#RESULT})"
          
          if [ -z "$RESULT" ]; then
            echo "❌ Error: No text content in API response"
            echo "Response structure:"
            echo "$RESPONSE_BODY" | jq '.' 2>/dev/null || echo "$RESPONSE_BODY"
            echo "result=" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Extract JSON from markdown code blocks if present
          if echo "$RESULT" | grep -q '```'; then
            echo "Extracting JSON from markdown code blocks..."
            RESULT=$(echo "$RESULT" | sed -n '/```json/,/```/p' | sed '1d;$d' || echo "$RESULT" | sed -n '/```/,/```/p' | sed '1d;$d')
          fi
          
          echo "Final result: $RESULT"
          echo "result<<EOF" >> $GITHUB_OUTPUT
          echo "$RESULT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "✅ Analysis complete. Result saved to output."

      - name: Close duplicate issue
        if: steps.analyze_duplicates.outcome == 'success' && steps.analyze_duplicates.outputs.result != ''
        uses: actions/github-script@v8
        env:
          DUPLICATE_RESULT: ${{ steps.analyze_duplicates.outputs.result }}
          CURRENT_ISSUE_NUMBER: ${{ steps.current_issue.outputs.number }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const result = process.env.DUPLICATE_RESULT;
            const currentNumber = parseInt(process.env.CURRENT_ISSUE_NUMBER, 10);
            
            let analysis;
            try {
              analysis = JSON.parse(result);
            } catch (e) {
              core.error(`Failed to parse duplicate analysis: ${e.message}`);
              core.error(`Raw result: ${result}`);
              return;
            }
            
            core.info(`Analysis result: ${JSON.stringify(analysis)}`);
            
            if (!analysis.is_duplicate || analysis.confidence === 'low') {
              core.info(`Issue #${currentNumber} is not a duplicate (is_duplicate: ${analysis.is_duplicate}, confidence: ${analysis.confidence})`);
              return;
            }
            
            const canonicalNumber = analysis.canonical_issue_number;
            if (!canonicalNumber) {
              core.warning('Duplicate detected but no canonical issue number provided');
              return;
            }
            
            // Add comment
            const comment = `This issue appears to be a duplicate of #${canonicalNumber}.\n\n${analysis.reason || 'Closing as duplicate.'}\n\nPlease follow #${canonicalNumber} for updates.`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: currentNumber,
              body: comment
            });
            
            // Close the issue (disabled for manual confirmation flow)
            // await github.rest.issues.update({
            //   owner: context.repo.owner,
            //   repo: context.repo.repo,
            //   issue_number: currentNumber,
            //   state: 'closed',
            //   state_reason: 'not_planned'
            // });
            
            // Add duplicate label if it exists
            try {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: currentNumber,
                labels: ['duplicate']
              });
            } catch (e) {
              core.info('Could not add duplicate label (may not exist)');
            }
            
            core.info(`Closed issue #${currentNumber} as duplicate of #${canonicalNumber}`);
